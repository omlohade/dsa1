// The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.

// For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.
// Given an integer n, return its complement.

 

// Example 1:

// Input: n = 5
// Output: 2
// Explanation: 5 is "101" in binary, with complement "010" in binary, which is 2 in base-10.
// Example 2:

// Input: n = 7
// Output: 0
// Explanation: 7 is "111" in binary, with complement "000" in binary, which is 0 in base-10.
// Example 3:

// Input: n = 10
// Output: 5
// Explanation: 10 is "1010" in binary, with complement "0101" in binary, which is 5 in base-10.
 

// Constraints:

// 0 <= n < 109



class Solution {
public:
    int bitwiseComplement(int n) {
        // If n is 0, its complement should be 1
        if (n == 0) return 1;

        int m = n;  // Copy of n to determine the number of bits in n
        int mask = 0;  // Mask that will be used to extract only relevant bits

        // Generate a mask with the same number of bits as n, all set to 1
        while (m != 0) {
            mask = (mask << 1) | 1;  // Left shift mask by 1 and add 1 (builds a sequence of 1s)
            m = m >> 1;  // Right shift m to count how many bits n has
        }

        // Apply the mask to the bitwise NOT (~n) to ensure leading 1s do not interfere
        int comp = (~n) & mask;  

        return comp;  // Return the final complement value
    }
};
// Time Complexity: O(log(n))
// Space Complexity: O(1)
//explanation of code line by line
// The above code snippet is a solution to the problem that computes the bitwise complement of an integer n. The function bitwiseComplement takes an integer n as input and returns its complement. The function first handles the special case when n is 0 by returning 1 as its complement. It then calculates the number of bits in n by creating a mask with the same number of bits as n, all set to 1. The mask is generated by left-shifting the mask by 1 and adding 1 until m becomes 0. Finally, the function applies the mask to the bitwise NOT (~n) to ensure that only relevant bits are considered and returns the complement value. The time complexity of the function is O(log(n)), where n is the input integer, and the space complexity is O(1).